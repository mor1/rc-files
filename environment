#
# handy shell functions
#

[ -r ~/src/sh-scripts.git/envfns.sh ] && source ~/src/sh-scripts.git/envfns.sh
[ -r ~/src/sh-scripts.git/filefns.sh ] && source ~/src/sh-scripts.git/filefns.sh
[ -r ~/src/sh-scripts.git/numfns.sh ] && source ~/src/sh-scripts.git/numfns.sh
[ -r ~/src/sh-scripts.git/hosts.sh ] && source ~/src/sh-scripts.git/hosts.sh

#
# general
#

umask 0002

CDPATH=.:..:../..:../../..:../../../..:../../../../..:../../../../../..:../../../../../../..:../../../../../../../..:../../../../../../../../..:../../../../../../../../../..:$HOME
EDITOR=/usr/bin/vi
PAGER=less
MANPAGER="less -X"
export CDPATH EDITOR PAGER MANPAGER 

#
# bash settings
#

command_oriented_history=TRUE # multi-line commands become single line
notify=TRUE # support notifications

# so bash doesn't do variable expansion on (eg.) \w in PS1 -- consider
# the case of a dir. called "`rm -rf ~`" ... :-> (ask Austin)
export NO_PROMPT_VARS
set -o noclobber # require explicit overwrite when redirecting

#
# history settings
#

shopt -s histappend # continue appending, don't delete periodically
export PROMPT_COMMAND="history -a" # add every command to history
export HISTIGNORE="&:l[sl][a]:[bf]g:exit:[ \t]"
export HISTCONTROL=ignoreboth:erasedups
export HISTSIZE=10000
export HISTFILESIZE=10000

#
# paths
#

unset PATH
aenv PATH /sbin
aenv PATH /bin
aenv PATH /usr/sbin
aenv PATH /usr/bin
aenv PATH /usr/local/sbin
aenv PATH /usr/local/bin
aenv PATH /usr/X11R6/bin
aenv PATH /usr/local/texlive/2011/bin/x86_64-darwin
aenv PATH ~/bin
aenv PATH ~/bin/android-sdk-mac_86/tools
aenv PATH /usr/local/share/python

unset MANPATH
aenv MANPATH /usr/local/man
aenv MANPATH /usr/share/man
aenv MANPATH /usr/X11R6/man
aenv MANPATH /opt/local/man
aenv MANPATH /opt/local/share/man

aenv NODE_PATH /usr/local/lib/node

# stupid proxy settings
# export http_proxy="http://proxy.nottingham.ac.uk:8080"
export http_proxy="http://wwwcache.cs.nott.ac.uk:3128"
export no_proxy="localhost,127.0.0.1"

# cabal, haskell package management (for pandoc)
aenv MANPATH ~/.cabal/share/man
aenv PATH ~/.cabal/bin

# homebrew completion
source $(brew --prefix)/Library/Contributions/brew_bash_completion.sh

# pip bash completion start
_pip_completion()
{
    COMPREPLY=( $( COMP_WORDS="${COMP_WORDS[*]}" \
                   COMP_CWORD=$COMP_CWORD \
                   PIP_AUTO_COMPLETE=1 $1 ) )
}
complete -o default -F _pip_completion pip
# pip bash completion end

# ec2 ami tools
export JAVA_HOME="/System/Library/Frameworks/JavaVM.framework/Home"
export EC2_PRIVATE_KEY="$(/bin/ls $HOME/.ec2/pk-*.pem)"
export EC2_CERT="$(/bin/ls $HOME/.ec2/cert-*.pem)"
export EC2_AMITOOL_HOME="/usr/local/Cellar/ec2-ami-tools/1.3-45758/jars"

# ec2 api tools
export JAVA_HOME="/System/Library/Frameworks/JavaVM.framework/Home"
export EC2_PRIVATE_KEY="$(/bin/ls $HOME/.ec2/pk-*.pem)"
export EC2_CERT="$(/bin/ls $HOME/.ec2/cert-*.pem)"
export EC2_HOME="/usr/local/Cellar/ec2-api-tools/1.3-62308/jars"

# mirage tools
#aenv PATH ~/research/mirage/install/bin
# no aenv - it adds a trailing :
#export MIRAGELIB=~/research/mirage/install

# ocaml
export OCAMLRUNPARAM=b

###-begin-npm-completion-###
#
# npm command completion script
#
# Installation: npm completion >> ~/.bashrc  (or ~/.zshrc)
# Or, maybe: npm completion > /usr/local/etc/bash_completion.d/npm
#

COMP_WORDBREAKS=${COMP_WORDBREAKS/=/}
COMP_WORDBREAKS=${COMP_WORDBREAKS/@/}
export COMP_WORDBREAKS

if complete &>/dev/null; then
  _npm_completion () {
    local si="$IFS"
    IFS=$'\n' COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
                           COMP_LINE="$COMP_LINE" \
                           COMP_POINT="$COMP_POINT" \
                           npm completion -- "${COMP_WORDS[@]}" \
                           2>/dev/null)) || return $?
    IFS="$si"
  }
  complete -F _npm_completion npm
elif compctl &>/dev/null; then
  _npm_completion () {
    local cword line point words si
    read -Ac words
    read -cn cword
    let cword-=1
    read -l line
    read -ln point
    si="$IFS"
    IFS=$'\n' reply=($(COMP_CWORD="$cword" \
                       COMP_LINE="$line" \
                       COMP_POINT="$point" \
                       npm completion -- "${words[@]}" \
                       2>/dev/null)) || return $?
    IFS="$si"
  }
  compctl -K _npm_completion npm
fi
###-end-npm-completion-###
